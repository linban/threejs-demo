<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js 3D 交互模型</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
    </style>
</head>
<body>

<script>
    // 创建场景、相机和渲染器
    let scene = new THREE.Scene();
    let camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
    let renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // 添加光照
    let light = new THREE.AmbientLight(0xffffff);
    scene.add(light);

    // 创建一个立方体
    let geometry = new THREE.BoxGeometry();
    let material = new THREE.MeshNormalMaterial();
    let cube = new THREE.Mesh(geometry, material);
    scene.add(cube);

    // 设置相机位置
    camera.position.z = 5;

    // 交互逻辑：单指旋转，双指缩放
    let isDragging = false;
    let previousX, previousY;
    let lastScale = 1, startDistance = 0;

    // 计算双指间距离
    function getDistance(touches) {
        let dx = touches[0].clientX - touches[1].clientX;
        let dy = touches[0].clientY - touches[1].clientY;
        return Math.sqrt(dx * dx + dy * dy);
    }

    // 监听触摸事件
    window.addEventListener("touchstart", (event) => {
        if (event.touches.length === 1) {
            isDragging = true;
            previousX = event.touches[0].clientX;
            previousY = event.touches[0].clientY;
        } else if (event.touches.length === 2) {
            startDistance = getDistance(event.touches);
            lastScale = cube.scale.x;
        }
    });

    window.addEventListener("touchmove", (event) => {
        event.preventDefault();

        // 单指旋转
        if (isDragging && event.touches.length === 1) {
            let deltaX = event.touches[0].clientX - previousX;
            let deltaY = event.touches[0].clientY - previousY;
            previousX = event.touches[0].clientX;
            previousY = event.touches[0].clientY;

            cube.rotation.y += deltaX * 0.01;
            cube.rotation.x += deltaY * 0.01;
        }

        // 双指缩放
        if (event.touches.length === 2) {
            let newDistance = getDistance(event.touches);
            let scaleFactor = newDistance / startDistance;
            let newScale = lastScale * scaleFactor;
            cube.scale.set(newScale, newScale, newScale);
        }
    });

    window.addEventListener("touchend", () => {
        isDragging = false;
    });

    // 动画循环
    function animate() {
        requestAnimationFrame(animate);
        renderer.render(scene, camera);
    }
    animate();

</script>
</body>
</html>
